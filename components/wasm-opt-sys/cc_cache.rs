//! A caching layer for the `cc` crate,
//! compatible with `cxx_build`.
//!
//! ## Usage
//!
//! Call methods on it you would `cc::Build`,
//! then call `cc_cache::Build::apply` to apply
//! the build configuration to a real `cc::Build`;
//! either an empty `cc::Build` or one generated by
//! `cxx_build::bridge`.
//!
//! For source files that do not need to be rebuilt,
//! `apply` will tell the `cc::Build` to link directly
//! to the existing object file.
//!
//!
//! ## Conditions that trigger a full rebuild
//!
//! - if CC_FORCE_REBUILD is set
//! - if there is no cache config file
//! - if CC, CXX, CFLAGS, CXXFLAGS have changed
//! - if the `cc` or `cxx_build` crates have changed
//!   (use the `build-script-build` crate)
//! - if the set of include files has changed,
//!   (considering CFG.exported_header_dirs)
//! - if the Tool::path has changed
//! - if the modified time of Tool::path has changed
//! - if any property of Tool has changed?
//!
//!
//! ## Conditions that trigger a single file rebuild
//!
//! - if the object file does not exist
//! - if the object file has a modified time less than the source file
//!
//!
//! ## Todo
//!
//! Use `gcc -M` to get precise information about includes.

#![allow(unused)]

use std::path::{Path, PathBuf};

pub struct Build {
}

/// Methods from `cc::Build`.
impl Build {
    fn new() -> Build {
        todo!()
    }

    fn flag(&mut self, flag: &str) -> &mut Build {
        todo!()
    }

    pub fn file<P: AsRef<Path>>(&mut self, p: P) -> &mut Build {
        todo!()
    }

    pub fn files<P>(&mut self, p: P) -> &mut Build
    where
        P: IntoIterator,
        P::Item: AsRef<Path>,
    {
        todo!()
    }
}

/// Custom methods.
impl Build {
    /// Configures a `cc::Build`.
    ///
    /// If a source file does not need to be rebuilt,
    /// the `cc::Build` is instead told to link to the
    /// existing object file.
    pub fn apply(&self, cc: &mut cc::Build) {
        todo!()
    }

    fn should_full_rebuild(&self) -> bool {
        todo!()
    }

    fn source_action(&self, source_file: &Path) -> SourceAction {
        todo!()
    }

    fn store_build_cfg(&self) {
        todo!()
    }
}

enum SourceAction {
    Rebuild(PathBuf),
    ReuseObj(PathBuf),
}

